{
  "version": 3,
  "sources": ["../node_modules/@11ty/is-land/is-land.js", "../stuff/ssr-utils/lit-island.js"],
  "sourcesContent": ["class Island extends HTMLElement {\n  static tagName = \"is-land\";\n  static prefix = \"is-land--\";\n  static attr = {\n    template: \"data-island\",\n    ready: \"ready\",\n    defer: \"defer-hydration\",\n  };\n\n  static onceCache = new Map();\n  static onReady = new Map();\n\n  static fallback = {\n    \":not(is-land,:defined,[defer-hydration])\": (readyPromise, node, prefix) => {\n      // remove from document to prevent web component init\n      let cloned = document.createElement(prefix + node.localName);\n      for(let attr of node.getAttributeNames()) {\n        cloned.setAttribute(attr, node.getAttribute(attr));\n      }\n    \n      // Declarative Shadow DOM (with polyfill)\n      let shadowroot = node.shadowRoot;\n      if(!shadowroot) {\n        let tmpl = node.querySelector(\":scope > template:is([shadowrootmode], [shadowroot])\");\n        if(tmpl) {\n          let mode = tmpl.getAttribute(\"shadowrootmode\") || tmpl.getAttribute(\"shadowroot\") || \"closed\";\n          shadowroot = node.attachShadow({ mode }); // default is closed\n          shadowroot.appendChild(tmpl.content.cloneNode(true));\n        }\n      }\n    \n      // Cheers to https://gist.github.com/developit/45c85e9be01e8c3f1a0ec073d600d01e\n      if(shadowroot) {\n        cloned.attachShadow({ mode: shadowroot.mode }).append(...shadowroot.childNodes);\n      }\n    \n      // Keep *same* child nodes to preserve state of children (e.g. details->summary)\n      cloned.append(...node.childNodes);\n      node.replaceWith(cloned);\n    \n      return readyPromise.then(() => {\n        // Restore original children and shadow DOM\n        if(cloned.shadowRoot) {\n          node.shadowRoot.append(...cloned.shadowRoot.childNodes);\n        }\n        node.append(...cloned.childNodes);\n        cloned.replaceWith(node);\n      });\n    }\n  }\n\n  constructor() {\n    super();\n\n    // Internal promises\n    this.ready = new Promise(resolve => {\n      this.readyResolve = resolve;\n    });\n  }\n\n  // any parents of `el` that are <is-land> (with conditions)\n  static getParents(el, stopAt = false) {\n    let nodes = [];\n    while(el) {\n      if(el.matches && el.matches(Island.tagName)) {\n        if(stopAt && el === stopAt) {\n          break;\n        }\n\n        if(Conditions.hasConditions(el)) {\n          nodes.push(el);\n        }\n      }\n      el = el.parentNode;\n    }\n    return nodes;\n  }\n\n  static async ready(el, parents) {\n    if(!parents) {\n      parents = Island.getParents(el);\n    }\n    if(parents.length === 0) {\n      return;\n    }\n    let imports = await Promise.all(parents.map(p => p.wait()));\n    // return innermost module import\n    if(imports.length) {\n      return imports[0];\n    }\n  }\n\n  forceFallback() {\n    if(window.Island) {\n      Object.assign(Island.fallback, window.Island.fallback);\n    }\n\n    for(let selector in Island.fallback) {\n      // Reverse here as a cheap way to get the deepest nodes first\n      let components = Array.from(this.querySelectorAll(selector)).reverse();\n\n      // with thanks to https://gist.github.com/cowboy/938767\n      for(let node of components) {\n        if(!node.isConnected) {\n          continue;\n        }\n\n        let parents = Island.getParents(node);\n        // must be in a leaf island (not nested deep)\n        if(parents.length === 1) {\n          let p = Island.ready(node, parents);\n          Island.fallback[selector](p, node, Island.prefix);\n        }\n      }\n    }\n  }\n\n  wait() {\n    return this.ready;\n  }\n\n  async connectedCallback() {\n    // Only use fallback content with loading conditions\n    if(Conditions.hasConditions(this)) {\n      // Keep fallback content without initializing the components\n      this.forceFallback();\n    }\n\n    await this.hydrate();\n  }\n\n  getTemplates() {\n    return this.querySelectorAll(`template[${Island.attr.template}]`);\n  }\n\n  replaceTemplates(templates) {\n    // replace <template> with the live content\n    for(let node of templates) {\n      // if the template is nested inside another child <is-land> inside, skip\n      if(Island.getParents(node, this).length > 0) {\n        continue;\n      }\n\n      let value = node.getAttribute(Island.attr.template);\n      // get rid of the rest of the content on the island\n      if(value === \"replace\") {\n        let children = Array.from(this.childNodes);\n        for(let child of children) {\n          this.removeChild(child);\n        }\n        this.appendChild(node.content);\n        break;\n      } else {\n        let html = node.innerHTML;\n        if(value === \"once\" && html) {\n          if(Island.onceCache.has(html)) {\n            node.remove();\n            return;\n          }\n\n          Island.onceCache.set(html, true);\n        }\n\n        node.replaceWith(node.content);\n      }\n    }\n  }\n\n  async hydrate() {\n    let conditions = [];\n    if(this.parentNode) {\n      // wait for all parents before hydrating\n      conditions.push(Island.ready(this.parentNode));\n    }\n\n    let attrs = Conditions.getConditions(this);\n    for(let condition in attrs) {\n      if(Conditions.map[condition]) {\n        conditions.push(Conditions.map[condition](attrs[condition], this));\n      }\n    }\n\n    // Loading conditions must finish before dependencies are loaded\n    await Promise.all(conditions);\n\n    this.replaceTemplates(this.getTemplates());\n\n    for(let fn of Island.onReady.values()) {\n      await fn.call(this, Island);\n    }\n\n    this.readyResolve();\n\n    this.setAttribute(Island.attr.ready, \"\");\n\n    // Remove [defer-hydration]\n    this.querySelectorAll(`[${Island.attr.defer}]`).forEach(node => node.removeAttribute(Island.attr.defer));\n  }\n}\n\nclass Conditions {\n  static map = {\n    visible: Conditions.visible,\n    idle: Conditions.idle,\n    interaction: Conditions.interaction,\n    media: Conditions.media,\n    \"save-data\": Conditions.saveData,\n  };\n\n  static hasConditions(node) {\n    return Object.keys(Conditions.getConditions(node)).length > 0;\n  }\n\n  static getConditions(node) {\n    let map = {};\n    for(let key of Object.keys(Conditions.map)) {\n      if(node.hasAttribute(`on:${key}`)) {\n        map[key] = node.getAttribute(`on:${key}`);\n      }\n    }\n\n    return map;\n  }\n\n  static visible(noop, el) {\n    if(!('IntersectionObserver' in window)) {\n      // runs immediately\n      return;\n    }\n\n    return new Promise(resolve => {\n      let observer = new IntersectionObserver(entries => {\n        let [entry] = entries;\n        if(entry.isIntersecting) {\n          observer.unobserve(entry.target);\n          resolve();\n        }\n      });\n\n      observer.observe(el);\n    });\n  }\n\n  // Warning: on:idle is not very useful with other conditions as it may resolve long before.\n  static idle() {\n    let onload = new Promise(resolve => {\n      if(document.readyState !== \"complete\") {\n        window.addEventListener(\"load\", () => resolve(), { once: true });\n      } else {\n        resolve();\n      }\n    });\n\n    if(!(\"requestIdleCallback\" in window)) {\n      // run immediately\n      return onload;\n    }\n\n    // both idle and onload\n    return Promise.all([\n      new Promise(resolve => {\n        requestIdleCallback(() => {\n          resolve();\n        });\n      }),\n      onload,\n    ]);\n  }\n\n  static interaction(eventOverrides, el) {\n    let events = [\"click\", \"touchstart\"];\n    // event overrides e.g. on:interaction=\"mouseenter\"\n    if(eventOverrides) {\n      events = (eventOverrides || \"\").split(\",\").map(entry => entry.trim());\n    }\n\n    return new Promise(resolve => {\n      function resolveFn(e) {\n        resolve();\n\n        // cleanup the other event handlers\n        for(let name of events) {\n          el.removeEventListener(name, resolveFn);\n        }\n      }\n\n      for(let name of events) {\n        el.addEventListener(name, resolveFn, { once: true });\n      }\n    });\n  }\n\n  static media(query) {\n    let mm = {\n      matches: true\n    };\n\n    if(query && (\"matchMedia\" in window)) {\n      mm = window.matchMedia(query);\n    }\n\n    if(mm.matches) {\n      return;\n    }\n\n    return new Promise(resolve => {\n      mm.addListener(e => {\n        if(e.matches) {\n          resolve();\n        }\n      });\n    });\n  }\n\n  static saveData(expects) {\n    // return early if API does not exist\n    if(!(\"connection\" in navigator) || navigator.connection.saveData === (expects !== \"false\")) {\n      return;\n    }\n\n    // dangly promise\n    return new Promise(() => {});\n  }\n}\n\n// Should this auto define? Folks can redefine later using { component } export\nif(\"customElements\" in window) {\n  window.customElements.define(Island.tagName, Island);\n  window.Island = Island;\n}\n\nexport {\n  Island,\n  Island as component, // Backwards compat only: recommend `Island` export\n};\n\n// TODO remove in 4.0\nexport const ready = Island.ready; // Backwards compat only: recommend `Island` export\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Island } from '@11ty/is-land';\n\ncustomElements.define(\n  'lit-island',\n  class extends Island {\n    // Removes the feature in which 11ty island removes DOM to render a fallback.\n    forceFallback() {}\n  },\n);\n"],
  "mappings": "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",
  "names": []
}
